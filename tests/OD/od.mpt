Event InputL, OutputL, Write {
  id: UInt64,
  addr: UInt64,
  x: UInt64
};

mpt OD {
  in t1 : [InputL, OutputL, Write], t2: [InputL, OutputL, Write];
  out o : Bool;

  -- initial state
  init q0;

  q0 -> q0 {
    t1: _*e1@{InputL + OutputL};
    t2: _*e2@{InputL + OutputL};
    cond: t1[e1] == t2[e2];
  }
  q0 -> q1 {
    t1: _*e1@{OutputL + $};
    t2: _*e2@{OutputL + $};
    cond: t1[e1] != t2[e2];
    out: false;
  }
  q0 -> q2 {
    t1: _*e1@{InputL + $};
    t2: _*e2@{InputL + $};
    cond: t1[e1] != t2[e2];
    out: true;
  }
}


















  -- could be also t1, ..., t2: [InputL, OutputL];
  -- OutputL can be either a single value or a trace of values


-- sources {
--   import listendir  -- introduces the function listendir
--   import csv        -- introduces the functions `csv` and `csvn`
--
--   foreach file in listendir($arg1) {
--     let t = new [InputL, OutputL];
--     foreach line in @csv.enumerate_csv(file, sep=" ") {
--       if line[0] == 0 {
--         yield InputL(line[2], line[3]) to t;
--       } else {
--         yield OutputL(line[2], line[3]) to t;
--       }
--     }
--   }
-- }

-- sources {
--   import random  -- introduces the function `rand`, `pick`, and `~` notation
--
--   let traces_num = pick()
--   foreach file in listendir($arg1) {
--     let t = new [InputL, OutputL];
--     foreach line in csvn(file, sep=" ") {
--       if line[0] == 0 {
--         yield InputL(line[2], line[3]) to t;
--       } else {
--         yield OutputL(line[2], line[3]) to t;
--       }
--     }
--   }
-- }
